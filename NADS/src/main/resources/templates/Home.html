<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<!--<meta name=description content="This site was generated with Anima. www.animaapp.com"/>-->
<!-- <link rel="shortcut icon" type=image/png href="https://animaproject.s3.amazonaws.com/home/favicon.png" /> -->
<meta name="viewport" content="width=1440, maximum-scale=1.0" />
<link rel="shortcut icon" type="image/png"
   href="https://animaproject.s3.amazonaws.com/home/favicon.png" />
<meta name="og:type" content="website" />
<meta name="twitter:card" content="photo" />
<link rel="stylesheet" type="text/css" href="css/desktop-1.css" />
<link rel="stylesheet" type="text/css" href="css/styleguide.css" />
<link rel="stylesheet" type="text/css" href="css/globals.css" />
<link rel="stylesheet" type="text/css" href="css/Home.css" />
<style>

#subtext {
            font-size: 20px; /* 글자 크기 조정 */
            font-family: Arial, sans-serif; /* 원하는 폰트로 변경 */
            font-weight: bold; /* 옵션: 글자 굵기 조정 */
            color: #333333; /* 옵션: 글자 색상 조정 */
        }
        
        
        

.notification-container {
   position: fixed;
   top: 10%;
   right: 2%;
   width: 300px;
   z-index: 1000;
   background: #fff;
   box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
   border-radius: 5px;
   padding: 15px;
   display: none;
}

.notification-header {
   display: flex;
   justify-content: space-between;
   align-items: center;
}

.notification-title {
   font-weight: bold;
   font-size: 16px;
   color: #e74c3c;
}

.notification-close {
   cursor: pointer;
   background: none;
   border: none;
   font-size: 18px;
}

.notification-body {
   margin-top: 10px;
   font-size: 14px;
   color: #333;
}
</style>
</head>
<body style="margin: 0; background: #f5f6fa">
   <input type="hidden" id="anPageName" name="page" value="desktop-1" />
   <div class="container-center-horizontal">
      <div class="desktop-1 screen">
         <div class="overlap-group16">
            <div class="overlap-group15">
               <div class="overlap-group10">


                  <div class="navigation-sidebar-1">
                     <div class="overlap-group-1">


                        <!-- 사이드바 시작 -->


                        <a href="/main">
                           <div class="navigation-sidebar-item-light2">
                              <div
                                 class="products-1 products-8 nunitosans-semi-bold-shark-14px">Home</div>
                           </div>
                        </a> <a href="/map">
                           <div class="navigation-sidebar-item-light3">
                              <div
                                 class="products-2 products-8 nunitosans-semi-bold-shark-14px">Traffic</div>
                           </div>
                        </a> <a href="/monthGph">
                           <div class="navigation-sidebar-item-light4">
                              <div
                                 class="products-3 products-8 nunitosans-semi-bold-shark-14px">Session</div>
                           </div>
                        </a> <a href="/weekGph">
                           <div class="navigation-sidebar-item-light5">
                              <div
                                 class="products-4 products-8 nunitosans-semi-bold-shark-14px">Cpu</div>
                           </div>
                        </a> <a href="/countryGph">
                           <div class="navigation-sidebar-item-light6">
                              <div
                                 class="products-5 products-8 nunitosans-semi-bold-shark-14px">Memories</div>
                           </div>
                        </a> <img class="divider" src="img/divider.svg" alt="Divider" />
                        <div class="pages">PAGES</div>



                        <!-- 클래스 수정 -->
                        <a href="/setting">
                           <div
                              class="navigation-sidebar-item-light-1 navigation-sidebar-item-light-3">

                              <div
                                 class="products-6 products-8 nunitosans-semi-bold-shark-14px">Setting</div>
                           </div>
                        </a>
                        <!-- 클래스 수정 -->

                     </div>

                     <!-- 사이드바 끝 -->

                     <img class="divider-1 divider-7" src="img/divider.svg"
                        alt="Divider" /> <img class="divider-2 divider-7"
                        src="img/divider.svg" alt="Divider" /> <img
                        class="group-1000000873" src="img/group-1000000873@2x.png"
                        alt="Group 1000000873" />
                  </div>
                  <div class="navigation-top-bar-light">
                     <div class="overlap-group2">
                        <div class="icon">

                           <img class="path-1" src="img/base-1@2x.png" alt="Path" />
                        </div>

                        <div class="overlap-group3">
                           <div class="overlap-group-3">

                              <div class="icon-1" onclick="toggleNotification()">

                                 <img class="combined-shape" src="img/combined-shape.svg"
                                    alt="Combined Shape" />
                                 <div class="rectangle-23"></div>
                              </div>
                              <img class="oval" src="img/oval-1.svg" alt="Oval" />
                              <div class="number">6</div>
                           </div>
                           <img class="oval-1" src="img/oval.svg" alt="Oval" />
                        </div>


                        <div class="profile">
                           <img class="man-438081_960_720"
                              src="img/man-438081-960-720@2x.png" alt="man-438081_960_720" />
                           <div class="flex-col">
                              <div class="jone-aly" th:text="${session.userName}">Moni Roy</div>
                              <div class="admin">Admin</div>
                           </div>
                           <img class="more" src="img/more@2x.png" alt="More" />
                        </div>
                     </div>
                  </div>
               </div>
               <div class="flex-col-1 flex-col-3">
                  <div class="overlap-group-container">
                     <div class="overlap-group1">
                        <iframe
                           src="http://223.130.139.47:5601/app/dashboards#/view/b73f71b0-9be1-11ef-aa42-b793711d88be?embed=true&_g=(filters%3A!()%2CrefreshInterval%3A(pause%3A!t%2Cvalue%3A0)%2Ctime%3A(from%3Anow-1d%2Fd%2Cto%3Anow))&hide-filter-bar=true"
                           height="230" width="1138"></iframe>
                     </div>
                  </div>
                  <div class="product-card">
                     <div class="overlap-group5">
                        <div class="box-4 box-5"></div>

                        <!-- 수정한 부분 임 -->
                        <div class="overlap-group5">
                           <div class="box-4 box-5">
                              <!-- 연주가 추가한 트래픽 그래프 -->
                              <!-- 날짜 및 시간대 설정 -->
                              <div align="center" id="choiceDetail">
                                 <form action="/api/elastic/all" id="choiceDateForm">
                                    <label for="choiceDate">시작</label> <input
                                       type="datetime-local" id="choiceDate" name="choiceDate">
                                    <label for="choiceDateEnd">종료 </label> <input
                                       type="datetime-local" id="choiceDateEnd"
                                       name="choiceDateEnd">
                                    <button type="submit">조회</button>
                                 </form>
                              </div>

                              <!-- 일시정지, 재생 버튼 -->
                              <div align="right" id="playOrstop">

                              <div id="subtext" >
                                  <!-- 그래프 날짜 -->
                                  <span align="left">조회일자 : </span><span id="dateValue"></span>
                                  <div id="selectedDate" align="left"></div>
                                                         
                                  <!-- 텍스트 -->
                                  <div align="left">실시간 Traffic 발생량</div>
                              
                                  <!-- 차트 -->
                                  <canvas id="lineChart" height="400" width="1098"></canvas>
                              </div>

                                 <button id="tempStopTraffic">일시정지</button>
                                 <button id="playTraffic">재생</button>
                              </div>

                              <!-- ============추후에 세션 그래프로 바꿀 예정================== -->
                              <!-- 연주가 추가한 트래픽 그래프 -->

                              <!-- 일시정지, 재생 버튼 -->
                              <div align="right" id="playOrstop">

                              <!-- 텍스트 -->
                              <div id="subtext" align="left">실시간 Session 발생량</div>


                                 <div>
                                    <!-- 그래프 날짜 -->
                                    <div id="selectedDate" align="left"></div>
                                    <canvas id="lineChartSession" height="400" width="1098"></canvas>
                                 </div>
                              
                                 <button id="tempStopSession">일시정지</button>
                                 <button id="playSession">재생</button>
                              </div>

                              <!-- 텍스트 -->
                              <div id="subtext" align="left">접속 IP별 국가통계</div>

                              <!-- 기존 키바나 그래프 -->
                              <div class="iframe-container">
                                 <iframe
                                    src="http://223.130.139.47:5601/app/dashboards#/view/c1ea3c70-9a66-11ef-aa42-b793711d88be?embed=true&_g=(filters%3A!()%2CrefreshInterval%3A(pause%3A!t%2Cvalue%3A0)%2Ctime%3A(from%3Anow-15m%2Cto%3Anow))&hide-filter-bar=true"
                                    height="460" width="1138"></iframe>



                              </div>
                              <!-- Insert the canvas for the bar chart above the image -->
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </div>

      <!-- 알림 컨테이너 -->
      <div id="notification" class="notification-container">
         <div class="notification-header">
            <span class="notification-title">Warning: High Traffic
               Detected</span>
            <button class="notification-close" onclick="closeNotification()">&times;</button>
         </div>
         <div class="notification-body">
            - Traffic increased significantly.<br> - Immediate action
            required.
         </div>
      </div>

      <!-- Chart.js -->
      <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

      <!-- jQuery CDN 설치 -->
      <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

      <script
         src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@latest"></script>


      <!-- ================================================================================ -->
    <script>
         $(document).ready(function(){
            // 전역 변수
            let lineChartTraffic;
            let dateTraffic = [];      // x축에 들어갈 날짜
            let tfData = [];   // Traffic
            let thData = [];   // Threshold
            let maxYValueTraffic = 0;   // y축 최대값
            const visibleCountTraffic = 8;   // 그래프에서 한 번에 보여줄 데이터 개수
            let startIndexTraffic = 0;         // 그래프 시작 인덱스 0
            let isPausedTraffic = false;
            let count = 0;
            let isFirstLoadTraffic = true; // 첫 로드 여부를 추적하는 변수
            let isRealTimeModeTraffic = true; // 실시간 업데이트 모드 여부
            let updateIntervalTraffic;
            
            // 웹 소켓 연결 설정 : WebSocket 서버의 URL 설정
            const host = window.location.hostname;
            const port = "8081";
            const socket = new WebSocket(`ws://${host}:${port}/traffic`);
            
            // 조회 버튼 클릭 시 선택한 날짜를 WebSocket으로 전송
              $('#choiceDateForm').on('submit', function(e) {
                  e.preventDefault();
                  const startDate = $('#choiceDate').val();
                  const endDate = $('#choiceDateEnd').val();
                  
                  const dateRange = {
                      startDate: startDate || null,
                      endDate: endDate || null
                  };
                  
                  if (startDate && endDate) {
                     isRealTimeModeTraffic = false; // 기간 선택 모드
                      socket.send(JSON.stringify(dateRange));
                  }
                  
              });
            
            socket.onopen = function(){
               console.log("WebSocket 연결이 열렸습니다.");
            };
            
            socket.onmessage = function(event){
               // 받은 메시지를 "\n" 기준으로 분리하여 dataTraffic과 dataThresh로 구분
                 const [dataTraffic, dataThresh] = event.data.split('\n');
                 const trafficData = JSON.parse(dataTraffic);
                 const thresholdData = JSON.parse(dataThresh);
                 //console.log("trafficData : ", trafficData);
                 //console.log("thresholdData : ", thresholdData);
            
               // 받은 데이터 처리
               if(!isPausedTraffic && trafficData && thresholdData){
                  // ========== 기간 선택 모드일 경우 기존 데이터 지우고 새로 업데이트
                  if(!isRealTimeModeTraffic){
                     dateTraffic = [];
                     tfData = [];
                     thData = [];
                     trafficData.forEach((item, index) => {
	                     const timeString = item.key_as_string.split("T")[1];   // 날짜 데이터의 T 문자를 기준으로 두 개의 배열로 나누되, 1번째 배열값 가져오기
	                     const hour = timeString.substring(0, 2);             // 인덱싱 >> 22:53:00 중 "22"
	                     const minute = timeString.substring(3, 5);             // 인덱싱 >> 22:53:00 중 "53"
	                     const formattedTime = `${hour}시 ${minute}분`;
	                      
	                     dateTraffic.push(formattedTime);
	                     tfData.push(item.value);
	                     thData.push(index < thresholdData.length ? thresholdData[index].value : null);
                     });
                     
                        // 첫 번째 데이터의 월/일을 #selectedDate에 표시
                   if (trafficData.length > 0) {
                     // 날짜 배열의 시작값
                      const startDateString = trafficData[0].key_as_string.split("T")[0];
                      const startMonth = startDateString.substring(5, 7);
                      const startDate = startDateString.substring(8, 10);
                      // 시작 요일 설정
                      const startDay = new Date(startDateString).toLocaleDateString('ko-KR', { weekday: 'short' }); // '월', '화' 등 요일 표시
                      
                      // 날짜 배열의 마지막값
                      const endDateString = trafficData[trafficData.length - 1].key_as_string.split("T")[0];
                      const endMonth = endDateString.substring(5, 7);
                      const endDate = endDateString.substring(8, 10);
                      // 끝 요일 설정
                      const endDay = new Date(endDateString).toLocaleDateString('ko-KR', { weekday: 'short' }); 
                      
                      if(startMonth !== endMonth || startDate !== endDate){
                         $('#selectedDate').text(`${startMonth}월 ${startDate}일 (${startDay}) ~ ${endMonth}월 ${endDate}일 (${endDay})`);
                      }else{
                         $('#selectedDate').text(`${startMonth}월 ${startDate}일 (${startDay})`);
                      }
                   }
                   isRealTimeModeTraffic = true;
                   
                  }else{   // ========== 기간 선택 모드가 아닌 초기 조회 데이터
                     if(isFirstLoadTraffic){
                        trafficData.forEach((item, index) => {
		                    const timeString = item.key_as_string.split("T")[1];   // 날짜 데이터의 T 문자를 기준으로 두 개의 배열로 나누되, 1번째 배열값 가져오기
		                    const hour = timeString.substring(0, 2);             // 인덱싱 >> 22:53:00 중 "22"
		                    const minute = timeString.substring(3, 5);             // 인덱싱 >> 22:53:00 중 "53"
		                    const formattedTime = `${hour}시 ${minute}분`;
		                    dateTraffic.push(formattedTime);
		                    tfData.push(item.value);
		                    thData.push(index < thresholdData.length ? thresholdData[index].value : null);
                           	console.log("thData : ", thData);
                        });
                        
                          // 첫 번째 데이터의 월/일을 #selectedDate에 표시
                     	 if (trafficData.length > 0) {
                         // 날짜 배열의 시작값
                         const startDateString = trafficData[0].key_as_string.split("T")[0];
                         const startMonth = startDateString.substring(5, 7);
                         const startDate = startDateString.substring(8, 10);
                         // 시작 요일 설정
                         const startDay = new Date(startDateString).toLocaleDateString('ko-KR', { weekday: 'short' }); // '월', '화' 등 요일 표시
                         
                         // 날짜 배열의 마지막값
                         const endDateString = trafficData[trafficData.length - 1].key_as_string.split("T")[0];
                         const endMonth = endDateString.substring(5, 7);
                         const endDate = endDateString.substring(8, 10);
                         // 끝 요일 설정
                         const endDay = new Date(endDateString).toLocaleDateString('ko-KR', { weekday: 'short' }); 
                         
                         if(startMonth !== endMonth || startDate !== endDate){
                            $('#selectedDate').text(`${startMonth}월 ${startDate}일 (${startDay}) ~ ${endMonth}월 ${endDate}일 (${endDay})`);
                         }else{
                            $('#selectedDate').text(`${startMonth}월 ${startDate}일 (${startDay})`);
                         }
                      }
                      isFirstLoadTraffic = false; // 초기 로드 완료
                     }else{
                        // 실시간 모드에서 새 데이터 추가
                        const latestTraffic = trafficData[trafficData.length - 1];
                        const latestThreshold = thresholdData[thresholdData.length - 1];
                        console.log("latestTraffic : ", latestTraffic);
                        console.log("latestThreshold : ", latestThreshold);
                        
                        // 실시간 데이터가 존재할 경우 추가
                        if (latestTraffic && latestTraffic.key_as_string) {
                         const timeString = latestTraffic.key_as_string.split("T")[1];   
	                     const hour = timeString.substring(0, 2);             
	                     const minute = timeString.substring(3, 5);             
	                     const formattedTime = `${hour}시 ${minute}분`;
	                      
                     	 dateTraffic.push(formattedTime);
                         tfData.push(latestTraffic.value);
                         thData.push(latestThreshold ? latestThreshold.value : null);
   
                          // visibleCount 초과 시 이전 데이터 제거
                          if (dateTraffic.length > visibleCountTraffic) {
                             dateTraffic.shift();
                             tfData.shift();
                             thData.shift();
                           }
                        }
                     }
                  }
               }
                  
               updateMaxYValueTraffic();
               
            };
            
            socket.onclose = function(){
               console.log("WebSocket 연결이 닫혔습니다.");
            } 
            
            
            // y축 최대값 업데이트 할 수 있는 함수
            function updateMaxYValueTraffic() {
               maxYValueTraffic = 0;   // 그래프를 여러 번 조회할 때 최대값이 누적되지 않도록 값을 초기화
               
             // tfData와 thData가 비어 있을 경우 0을 기본 값으로 사용
             const maxTfData = tfData.length > 0 ? Math.max(...tfData) : 0;
             const maxThData = thData.length > 0 ? Math.max(...thData) : 0;
         
             // tfData와 thData 중 더 큰 값에 1000을 더하고 1000 단위로 올림
             const maxCombinedValue = Math.max(maxTfData, maxThData) + 1000;
             maxYValueTraffic = Math.ceil(maxCombinedValue / 1000) * 1000;
             
             updateTrafficChart();
         }
            
            
            function updateTrafficChart(){
               if(lineChartTraffic){
                  lineChartTraffic.destroy();
               }
               
               const ctxTraffic = document.getElementById('lineChart').getContext('2d');
               
               lineChartTraffic = new Chart(ctxTraffic, {
                  type: 'line',
                  data: {
                     labels: dateTraffic.slice(startIndexTraffic, startIndexTraffic + visibleCountTraffic),
                     datasets: [
                        {
                           label: 'Traffic',
                           data: tfData.slice(startIndexTraffic, startIndexTraffic + visibleCountTraffic),
                           tension: 0.5,
                           borderColor: 'rgb(68, 113, 218)',
                           borderWidth: 2,
                           pointRadius: 0,
                           fill: {         // 임계값 설정 후 적용할 내용
                              target: 1,
                              above: 'rgba(204, 61, 61, 0.4)',
                              below: 'rgba(255, 255, 255, 0)'
                              
                           }
                        },
                        {
                           label: 'Threshold',
                           data: thData.slice(startIndexTraffic, startIndexTraffic + visibleCountTraffic),
                           tension: 0.5,
                           borderColor: 'rgb(255, 51, 51)',
                           borderWidth: 2,
                           pointRadius: 0,
                        } 
                     ]
                  },
                  options: {
                     responsive: true,
                     scales: {
                        x: {
                           grid: {
                              display: false
                           }
                        },
                        y: {
                           beginAtZero: true,   // 축이 0부터 시작할지 여부
                           max: maxYValueTraffic
                        }
                     },
                     plugins: {
                        tooltip: {   // chart 위에 마우스를 올리면 데이터 포인트와 관련된 정보 표시
                           intersect: false,   // 마우스가 정확히 데이터 포인트 위에 있을 때만 표시될지 여부
                                          // 기본값 : true, false면 포인트 가까이만 있어도 tooltip 표시
                           displayColors: false,   // label의 색상 상자 표시 여부
                           titleFont: {
                              size: 20,
                              family: 'Rethink Sans',
                              weight: 'bold'
                           },
                           bodyFont: {
                              size: 15,
                              family: 'Rethink Sans'
                           },
                           cornerRadius: 10,   // tooltip 둥근 모서리(기본값 : 6)
                           caretSize: 8,      // tooltip이 차트 요소를 가리키는 작은 삼각형
                           callbacks: {
                              title: function(tooltipItems){
                                 return 'Details';
                              },
                              label: function(tooltipItems){
                                 if(tooltipItems.datasetIndex === 0){
                                    return '• Traffic  :  '+tooltipItems.raw;
                                 }else if(tooltipItems.datasetIndex === 1){
                                    return '• Threshold  :  '+tooltipItems.raw;
                                 }
                              },
                              afterLabel: function(tooltipItems){
                                 const afterLabelInfo = [];
                                 const dataIndex = tooltipItems.dataIndex + startIndexTraffic;
                                  
                                 if(dataIndex < dateTraffic.length){
                                    const formattedDate = dateTraffic[dataIndex]; // "HH:MM:SS" 형식
                                     afterLabelInfo.push('• Date  :  ' + formattedDate);
                                 }
                                 
                                 return afterLabelInfo;
                              }
                           }
                        }
                     },
                     hover : {
                        mode: 'index',      // 마우스를 올렸을 때 반응하는 차트 요소의 범위
                        intersect: false   // 마우스가 요소와 교차할 때만 호버 효과가 발생할지 여부 설정
                     },
                     animation: {
                        duration: 0
                     }
                  }
               });
            }
            
            //일시정지 버튼 클릭 시 차트 업데이트
            document.getElementById('tempStopTraffic').addEventListener('click', function(){
               isPausedTraffic = true;
               updateIntervalTraffic = null;
            });
            
            // 재생 버튼 클릭 시 차트 업데이트
            document.getElementById('playTraffic').addEventListener('click', function() {
                  // 기존 인터벌이 이미 멈춰있다면 재시작
                  if(isPausedTraffic){
                     isPausedTraffic = false;
                  console.log("그래프가 재생됩니다.");
                  }
              });
            
            
            
            function checkTraffic() {
                // 플래그 변수 선언
                let isThresholdExceeded = false;

                // 트래픽이 임계값을 넘을 때마다 count 증가
                for (let i = 0; i < tfData.length; i++) {
                    if (tfData[i] > thData[i]) {
                        isThresholdExceeded = true;
                        break; // 임계값 초과 시 더 이상 반복할 필요 없음
                    }
                }

                // 임계값 초과 시 count 증가 요청
                if (isThresholdExceeded) {
                    // 서버의 카운트 증가 API 호출
                    $.ajax({
                        url: "/api/incrementCount", // count 증가를 위한 서버의 엔드포인트
                        type: "POST",
                        success: function () {
                            console.log("Count incremented on the server.");

                            // count 증가 후, getDdingdongCount 호출을 위해 별도 AJAX 요청 추가
                            $.ajax({
                                url: "/api/getDdingdongCount",
                                type: "GET",
                                success: function (data) {
                                    console.log("Current count value: " + data);
                                },
                                error: function () {
                                    console.error("Error fetching count value from the server.");
                                }
                            });
                        },
                        error: function () {
                            console.error("Error incrementing count on the server.");
                        }
                    });
                }
            }

            // 트래픽 데이터를 주기적으로 확인하기 위해 10초마다 checkTraffic 함수를 호출
            setInterval(checkTraffic, 1000);
            
         });
         
      </script>


      <!-- ================================================================================ -->


      <!-- ============================여기는 언젠가 session 그래프 영역========================= -->
      <script>
         $(document).ready(function(){
            // 전역 변수
            let lineChart;
            let dateSession = [];      // x축에 들어갈 날짜
            let scData = [];   // Traffic
            let sthData = [];   // Threshold
            let maxYValue = 0;   // y축 최대값
            const visibleCount = 8;   // 그래프에서 한 번에 보여줄 데이터 개수
            let startIndex = 0;         // 그래프 시작 인덱스 0
            let isPaused = false;
            let count = 0;
            let isFirstLoad = true; // 첫 로드 여부를 추적하는 변수
            let isRealTimeMode = true; // 실시간 업데이트 모드 여부
            let updateInterval;
            
            // 웹 소켓 연결 설정 : WebSocket 서버의 URL 설정
            const host = window.location.hostname;
            const port = "8081";
            const socket = new WebSocket(`ws://${host}:${port}/session`);
            
            // 조회 버튼 클릭 시 선택한 날짜를 WebSocket으로 전송
              $('#choiceDateForm').on('submit', function(e) {
                  e.preventDefault();
                  const startDate = $('#choiceDate').val();
                  const endDate = $('#choiceDateEnd').val();
                  
                  const dateRange = {
                      startDate: startDate || null,
                      endDate: endDate || null
                  };
                  
                  if (startDate && endDate) {
                      isRealTimeMode = false; // 기간 선택 모드
                      socket.send(JSON.stringify(dateRange));
                  }
                  
              });
            
            socket.onopen = function(){
               console.log("WebSocket 연결이 열렸습니다.");
            };
            
            socket.onmessage = function(event){
               // 받은 메시지를 "\n" 기준으로 분리하여 dataTraffic과 dataThresh로 구분
                 const [dataSession, dataSessionThresh] = event.data.split('\n');
                 const sessionData = JSON.parse(dataSession);
                 const sessionThreshData = JSON.parse(dataSessionThresh);
            
               // 받은 데이터 처리
               if(!isPaused && sessionData && sessionThreshData){
                  // ========== 기간 선택 모드일 경우 기존 데이터 지우고 새로 업데이트
                  if(!isRealTimeMode){
                     dateSession = [];
                     scData = [];
                     sthData = [];
                     sessionData.forEach((item, index) => {
	                     const timeString = item.key_as_string.split("T")[1];   // 날짜 데이터의 T 문자를 기준으로 두 개의 배열로 나누되, 1번째 배열값 가져오기
	                     const hour = timeString.substring(0, 2);             // 인덱싱 >> 22:53:00 중 "22"
	                     const minute = timeString.substring(3, 5);             // 인덱싱 >> 22:53:00 중 "53"
	                     const formattedTime = `${hour}시 ${minute}분`;
	                     dateSession.push(formattedTime);
	                     scData.push(item.value);
	                     sthData.push(index < sessionThreshData.length ? sessionThreshData[index].value : null);
                     });
                     isRealTimeMode = true;
                  }else{   // ========== 기간 선택 모드가 아닌 초기 조회 데이터
                     if(isFirstLoad){
                     sessionData.forEach((item, index) => {
	                     const timeString = item.key_as_string.split("T")[1];   // 날짜 데이터의 T 문자를 기준으로 두 개의 배열로 나누되, 1번째 배열값 가져오기
	                     const hour = timeString.substring(0, 2);             // 인덱싱 >> 22:53:00 중 "22"
	                     const minute = timeString.substring(3, 5);             // 인덱싱 >> 22:53:00 중 "53"
	                     const formattedTime = `${hour}시 ${minute}분`;
	                     dateSession.push(formattedTime);
	                     scData.push(item.value);
	                     sthData.push(index < sessionThreshData.length ? sessionThreshData[index].value : null);
                      });
                         isFirstLoad = false; // 초기 로드 완료
                     }else{
                        // 실시간 모드에서 새 데이터 추가
                        const latestSession = sessionData[sessionData.length - 1];
                        const latestSessionThresh = sessionThreshData[sessionThreshData.length - 1];
                        console.log("latestSession : ", latestSession);
                        console.log("latestSessionThresh : ", latestSessionThresh);
                        
                        // 실시간 데이터가 존재할 경우 추가
                        if (latestSession && latestSession.key_as_string) {
                          const timeString = latestSession.key_as_string.split("T")[1];   
                     const hour = timeString.substring(0, 2);             
                      const minute = timeString.substring(3, 5);             
                      const formattedTime = `${hour}시 ${minute}분`;
                      dateSession.push(formattedTime);
                           scData.push(latestSession.value);
                           sthData.push(latestSessionThresh ? latestSessionThresh.value : null);
   
                           // visibleCount 초과 시 이전 데이터 제거
                           if (dateSession.length > visibleCount) {
                              dateSession.shift();
                              scData.shift();
                              sthData.shift();
                           }
                        }
                     }
                  }
               }
                  
               updateMaxYValue();
               
            };
            
            socket.onclose = function(){
               console.log("WebSocket 연결이 닫혔습니다.");
            } 
            
            
            // y축 최대값 업데이트 할 수 있는 함수
            function updateMaxYValue() {
               //maxYValue = 0;   // 그래프를 여러 번 조회할 때 최대값이 누적되지 않도록 값을 초기화
               
             // tfData와 thData가 비어 있을 경우 0을 기본 값으로 사용
             const maxScData = scData.length > 0 ? Math.max(...scData) : 0;
             const maxSthData = sthData.length > 0 ? Math.max(...sthData) : 0;
         
             // tfData와 thData 중 더 큰 값에 1000을 더하고 1000 단위로 올림
             const maxCombinedValue = Math.max(maxScData, maxSthData) + 1000;
             maxYValue = Math.ceil(maxCombinedValue / 1000) * 1000;
             
             updateChart();
         }
            
            
            function updateChart(){
               if(lineChart){
                  lineChart.destroy();
               }
               
               const ctx = document.getElementById('lineChartSession').getContext('2d');
               
               lineChart = new Chart(ctx, {
                  type: 'line',
                  data: {
                     labels: dateSession.slice(startIndex, startIndex + visibleCount),
                     datasets: [
                        {
                           label: 'Session',
                           data: scData.slice(startIndex, startIndex + visibleCount),
                           tension: 0.5,
                           borderColor: 'rgb(0, 204, 0)',
                           borderWidth: 2,
                           pointRadius: 0,
                           fill: {         // 임계값 설정 후 적용할 내용
                              target: 1,
                              above: 'rgba(204, 61, 61, 0.4)',
                              below: 'rgba(255, 255, 255, 0)'
                           }
                        },
                        {
                           label: 'Threshold',
                           data: sthData.slice(startIndex, startIndex + visibleCount),
                           tension: 0.5,
                           borderColor: 'rgb(255, 51, 51)',
                           borderWidth: 2,
                           pointRadius: 0,
                        } 
                     ]
                  },
                  options: {
                     responsive: true,
                     scales: {
                        x: {
                           grid: {
                              display: false
                           }
                        },
                        y: {
                           beginAtZero: true,   // 축이 0부터 시작할지 여부
                           max: maxYValue
                        }
                     },
                     plugins: {
                        tooltip: {   // chart 위에 마우스를 올리면 데이터 포인트와 관련된 정보 표시
                           intersect: false,   // 마우스가 정확히 데이터 포인트 위에 있을 때만 표시될지 여부
                                          // 기본값 : true, false면 포인트 가까이만 있어도 tooltip 표시
                           displayColors: false,   // label의 색상 상자 표시 여부
                           titleFont: {
                              size: 20,
                              family: 'Rethink Sans',
                              weight: 'bold'
                           },
                           bodyFont: {
                              size: 15,
                              family: 'Rethink Sans'
                           },
                           cornerRadius: 10,   // tooltip 둥근 모서리(기본값 : 6)
                           caretSize: 8,      // tooltip이 차트 요소를 가리키는 작은 삼각형
                           callbacks: {
                              title: function(tooltipItems){
                                 return 'Details';
                              },
                              label: function(tooltipItems){
                                 if(tooltipItems.datasetIndex === 0){
                                    return '• Session  :  '+tooltipItems.raw;
                                 }else if(tooltipItems.datasetIndex === 1){
                                    return '• Threshold  :  '+tooltipItems.raw;
                                 }
                              },
                              afterLabel: function(tooltipItems){
                                 const afterLabelInfo = [];
                                 const dataIndex = tooltipItems.dataIndex + startIndex;
                                  
                                 if(dataIndex < dateSession.length){
                                    const formattedDate = dateSession[dataIndex]; // "HH:MM:SS" 형식
                                     afterLabelInfo.push('• Date  :  ' + formattedDate);
                                 }
                                 
                                 return afterLabelInfo;
                              }
                           }
                        }
                     },
                     hover : {
                        mode: 'index',      // 마우스를 올렸을 때 반응하는 차트 요소의 범위
                        intersect: false   // 마우스가 요소와 교차할 때만 호버 효과가 발생할지 여부 설정
                     },
                     animation: {
                        duration: 0
                     }
                  }
               });
            }
            
            //일시정지 버튼 클릭 시 차트 업데이트
            document.getElementById('tempStopSession').addEventListener('click', function(){
               isPaused = true;
               updateInterval = null;
            });
            
            // 재생 버튼 클릭 시 차트 업데이트
            document.getElementById('playSession').addEventListener('click', function() {
                  // 기존 인터벌이 이미 멈춰있다면 재시작
                  if(isPaused){
                  isPaused = false;
                  console.log("그래프가 재생됩니다.");
                  }
              });
            
         });
         
      </script>

      <!-- ================================================================================ -->
      <!-- ============ 준서꼬 ================ -->
         <script>
           
         </script>

<!-- ============ 준서 끝 ======================  -->


      <script>
      const ctx = document.getElementById('barChart') ? document.getElementById('barChart').getContext('2d') : null;

      if (ctx) {
         // Data and threshold
         const dataBar = [5000, 4700, 3800, 4900, 4300, 7200, 3100];
         const thresholdBar = 5000;

         // Generate color array based on threshold
         const bgColorBar = dataBar.map(value => value > thresholdBar ? 'rgba(237, 169, 0, 0.7)' : 'rgba(18, 105, 120, 0.7)');

         // Create bar chart
         new Chart(ctx, {
            type: 'bar',
            data: {
               labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
               datasets: [{
                  label: 'Traffic',
                  data: dataBar,
                  backgroundColor: bgColorBar,
               }]
            },
            options: {
               scales: {
                  y: {
                     beginAtZero: false,
                     min: 1000,
                     max: 7000,
                     grid: {
                        display: true
                     }
                  },
                  x: {
                     grid: {
                        display: false
                     }
                  }
               },
               plugins: {
                  annotation: {
                     annotations: {
                        thresholdLine: {
                           type: 'line',
                           yMin: thresholdBar,
                           yMax: thresholdBar,
                           borderColor: 'rgba(237, 169, 0, 1)',
                           borderWidth: 2,
                           label: {
                              content: 'Threshold',
                              enabled: true,
                              position: 'right'
                           }
                        }
                     }
                  }
               },
               barPercentage: 0.6
            }
         });
      }

      function toggleNotification() {
         document.getElementById('notification').style.display = 'block';
      }

      function closeNotification() {
         document.getElementById('notification').style.display = 'none';
      }

      /* 드롭박스 */
      function toggleDropdown() {
         const dropdown = document.getElementById('dropdownMenu');
         dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
      }

      function selectLanguage(language) {
         const flag = document.getElementById('languageFlag');
         const languageText = document.querySelector('.english .language');
         const dropdown = document.getElementById('dropdownMenu');
         const koreaMenuItem = document.getElementById('koreaMenuItem');
         const englishMenuItem = document.getElementById('englishMenuItem');

         if (language === 'Korea') {
            flag.src = 'img/korea.png'; // 플래그 이미지 변경
            languageText.textContent = 'Korea'; // 상단의 언어 이름 변경
            koreaMenuItem.style.display = 'none'; // 한국어 항목 숨김
            englishMenuItem.style.display = 'block'; // 영어 항목 보임
         } else {
            flag.src = 'img/English.png'; // English 이미지로 변경
            languageText.textContent = 'English'; // 상단의 언어 이름 변경
            koreaMenuItem.style.display = 'block'; // 한국어 항목 보임
            englishMenuItem.style.display = 'none'; // 영어 항목 숨김
         }

         dropdown.style.display = 'none'; // 드롭다운 닫기
      }
   </script>

<!--       <script>
    // 주기적으로 API를 호출하여 txRate와 traffic 비교
    setInterval(async function() {
        try {
            const response = await fetch('/api/alerts/check-alerts');
            const isAlert = await response.json();

            // 조건에 맞는 경우 알림 표시
            if (isAlert) {
                document.getElementById('notification').style.display = 'block';
            }
        } catch (error) {
            console.error('Error checking traffic alert:', error);
        }
    }, 5000); // 5초마다 확인 (필요에 따라 조정 가능)

    function closeNotification() {
        document.getElementById('notification').style.display = 'none';
    }
</script> -->
</body>
</html>
